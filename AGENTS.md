# Repository Guidelines

## Project Structure & Modules

- `tree-sitter-viewtree/`: Tree-sitter grammar (`grammar.js`), native sources, WASM, example file.
- `highlights/`: Syntax highlighting — TextMate (`tmLanguage.json`) and Tree‑sitter queries (`highlights.scm`).
- `server/`: Minimal LSP server (TypeScript) compiled to `out/server/`.
- `vscode/`: VS Code client that launches the LSP.
- `out/`: Build output (generated by `tsc`).

## Build, Test, and Dev

- Install: `npm i` (in repo root). Also `npm i` inside `tree-sitter-viewtree/` on first run.
- Build LSP: `npm run build` → emits JS to `out/`.
- Watch LSP: `npm run watch-server` → incremental `tsc`.
- Run server (standalone): `npm run start-server`.
- Grammar generate: `npm --prefix tree-sitter-viewtree run gen` (requires `tree-sitter` CLI). Playground: `npm --prefix tree-sitter-viewtree start`.
- Minimal test (grammar loads): `node --test tree-sitter-viewtree/bindings/node/binding_test.js` (run after generate/build).

## Coding Style & Naming

- TypeScript: ES2020, CommonJS, `strict: true` (see `ts-config.json`).
- Indentation: 2 spaces for TS/JS/JSON/SCM; C/C++ headers per `.editorconfig`.
- Names: `camelCase` for vars/functions, `PascalCase` for types/classes, file names lower-case (`index.ts`, `extension.ts`).
- Keep modules small and focused; prefer explicit exports.

## Testing Guidelines

- Framework: Node’s built-in `node:test` (see binding test). Add server tests under `server/` when feasible.
- Naming: mirror source path, e.g., `server/foo.test.ts` for `server/foo.ts`.
- Run: `node --test` with explicit file/glob; ensure grammar is generated before parser-dependent tests.

## Commit & Pull Requests

- Messages: imperative and scoped. Pattern: `feat(server): add semantic tokens` or `fix(grammar): null literal edge case`.
- PRs: include summary, rationale, before/after (screenshots for VS Code if UI-visible), steps to validate, and any perf/compat notes. Link issues.
- CI/readiness: PRs should build (`npm run build`) and pass tests you added.

## Security & Config Tips

- Requirements: Node 18+, `tree-sitter` CLI for grammar tasks, native build tools for Node addons.
- Do not commit `out/` or generated parser artifacts; keep changes to sources, queries, and TS.

# view.tree LSP — CODEX_PLAN

## Контекст

Мы пишем LSP-сервер для языка **view.tree** на базе **mol_tree2** (без Tree-sitter), чтобы дать:

- диагностику синтаксиса;
- автодополнение по контексту;
- hover-подсказки;
- переход к определению/ссылки;
- семантические токены (по возможности);
- переименование.

Клиенты: VS Code (через vscode-languageclient), потенциально Zed (через стандартный LSP).

## Ограничения

- Парсер: **mol_tree2** — единственный источник истины по синтаксису.
- Подсветка для VS Code — через TextMate (имеется); для Zed — отдельно (см. ниже).
- Никаких сетевых зависимостей.
- Node 18+, TypeScript 5+.

---

## Итерации (чёткие чек-пойнты)

### Iteration 0 — каркас

**Цель:** чистый запуск LSP и реакция на изменения.

- [ ] `server/index.ts`: createConnection, TextDocuments, onInitialize c capabilities.
- [ ] `documents.onDidChangeContent`: парсить текст через `mol_tree2_from_string`, логировать дерево.
- [ ] `sendDiagnostics([])` — пусто (пока).
      **Готово, когда:** клиент поднимается, лог без ошибок, изменения документа доходят до сервера.

### Iteration 1 — диагностика синтаксиса

**Цель:** превращаем ошибки mol_tree2 в LSP Diagnostic.

- [ ] Обернуть `mol_tree2_from_string` в «коллектор ошибок» через `$mol_ambient({ $mol_fail })`.
- [ ] Маппинг ошибок в `Diagnostic` (range из `span`, severity Error).
- [ ] Отправка через `connection.sendDiagnostics`.
      **Готово, когда:** ошибочные строки подсвечиваются в редакторе, тексты ошибок читаемы.

### Iteration 2 — поиск узла под курсором

**Цель:** бинарим позицию → AST-узел.

- [ ] Сервис `ast/index.ts`: `buildAst(doc: TextDocument) => Root`.
- [ ] `loc/index.ts`: `offset(doc, Position)`, `contains(span, offset)`.
- [ ] `findNodeAtOffset(root, offset)` — спуск по детям по span.
      **Готово, когда:** unit-тесты на поиск узла по позициям проходят.

### Iteration 3 — автодополнение (минимум)

**Цель:** контекстные подсказки.

- [ ] `completion/index.ts`: `onCompletion(params)`:
    - определить контекст (имя компонента, свойство, литерал и т.п.);
    - вернуть `CompletionItem[]` с корректным `kind`.
- [ ] Триггеры: `.` и `:` + ручной `Ctrl+Space`.
- [ ] Простейшие кандидаты: ключевые конструкции (`/`, `*`, `^`, `=`), базовые слова (`sub`, `prop` и т.д.).
      **Готово, когда:** список не пустой и зависит от позиции.

### Iteration 4 — автодополнение (проектные сущности)

**Цель:** реальные имена классов/свойств.

- [ ] Индексация рабочих файлов: собрать перечень `$Class` (из `.view.tree` и/или `.ts`).
- [ ] Для позиции «имя класса» предлагать найденные классы.
- [ ] Для позиции «имя свойства» — свойства текущего класса (минимум по текущему файлу).
      **Готово, когда:** подсказки подхватывают реальный проект.

### Iteration 5 — Hover

**Цель:** краткая справка по наведению.

- [ ] `onHover`: по узлу дать сводку (тип узла, путь, краткая семантика).
- [ ] По классу — путь до файла; по свойству — тип/источник, если известен.
      **Готово, когда:** появляется всплывающая подсказка над значимыми токенами.

### Iteration 6 — Go to Definition / References

**Цель:** навигация по символам.

- [ ] `onDefinition`: найти декларацию класса/свойства → `Location`.
- [ ] `onReferences`: собрать вхождения в рабочей области (по индексу/AST).
      **Готово, когда:** F12/Shift+F12 работают для классов/свойств.

### Iteration 7 — Semantic Tokens

**Цель:** базовая семантическая подсветка.

- [ ] Карта типов узлов → tokenType (class, property, keyword, string, number, operator).
- [ ] Выдача «полных» токенов при запросе клиента.
      **Готово, когда:** цвета меняются от Semantic Highlighting (если тема поддерживает).

### Iteration 8 — Rename

**Цель:** безопасное переименование класса/свойства.

- [ ] `prepareRename` — валидность позиции.
- [ ] `onRenameRequest` — возвращать `WorkspaceEdit` по всем вхождениям.
      **Готово, когда:** переименование обновляет все использования без ложных срабатываний.

---

## Структура каталогов (целевая)

server/
index.ts # wire LSP
ast/
build.ts # сборка AST через mol_tree2
findNode.ts # поиск узла по позиции
loc/
offset.ts # position <-> offset
span.ts # утилиты по span
diag/
collect.ts # сбор ошибок mol_tree2 -> Diagnostic[]
features/
completion.ts
hover.ts
definition.ts
references.ts
semanticTokens.ts
rename.ts

## Технические заметки

- **mol_tree2**: используем `$mol_span` для координат; ошибки через `$mol_error_syntax` и `$mol_fail`.
- Диапазоны: конвертация `span(row, col, len)` → LSP `Range` (строки/колонки 0-based).
- Индекс рабочего пространства: простая файловая индексация `.view.tree` (и по мере надобности `.ts`) по событию `workspace/didChangeWatchedFiles`.

## Тесты

- Юнит-тесты на:
    - парсинг и сбор ошибок (fixture с заведомыми ошибками);
    - поиск узла по позиции;
    - генерацию CompletionItem в разных контекстах.
- Интеграционный smoke: открыть пример проекта, проверить что приходят Diagnostics/Completion.

## Скрипты (npm)

- `build`: компиляция TS → `out/`
- `watch-server`: tsc -w
- `start-server`: node out/server/index.js --stdio
